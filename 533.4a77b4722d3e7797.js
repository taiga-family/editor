(self.webpackChunkeditor_demo=self.webpackChunkeditor_demo||[]).push([[533],{533:e=>{e.exports="import {AsyncPipe} from '@angular/common';\nimport {ChangeDetectionStrategy, Component, ViewChild} from '@angular/core';\nimport {FormControl, ReactiveFormsModule} from '@angular/forms';\nimport {WA_WINDOW} from '@ng-web-apis/common';\nimport {provideTuiEditor, TuiEditor, TuiEditorTool} from '@taiga-ui/editor';\nimport {type TableOfContentData} from '@tiptap/extension-table-of-contents';\nimport {Subject} from 'rxjs';\n\nimport {type MyContentsInfo, MyToc} from './my-toc';\n\n@Component({\n    standalone: true,\n    imports: [AsyncPipe, MyToc, ReactiveFormsModule, TuiEditor],\n    template: `\n        <tui-editor\n            [formControl]=\"control\"\n            [tools]=\"builtInTools\"\n        />\n\n        <my-table-of-contents [contents]=\"contents | async\" />\n    `,\n    styleUrls: ['./index.less'],\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        provideTuiEditor({}, async (injector) => {\n            const example = injector.get(Example);\n            const win = injector.get(WA_WINDOW);\n\n            const {TableOfContents, getHierarchicalIndexes} = await import(\n                '@tiptap/extension-table-of-contents'\n            );\n\n            return TableOfContents.configure({\n                scrollParent: () =>\n                    example.editor?.rootEl.querySelector<HTMLElement>('tui-scrollbar') ??\n                    win,\n                getIndex: getHierarchicalIndexes,\n                onUpdate(items: TableOfContentData, isCreate) {\n                    example.contents.next({items, isCreate});\n                },\n            });\n        }),\n    ],\n})\nexport default class Example {\n    protected readonly builtInTools = [\n        TuiEditorTool.Undo,\n        TuiEditorTool.Size,\n        TuiEditorTool.Bold,\n        TuiEditorTool.Italic,\n        TuiEditorTool.Underline,\n    ];\n\n    @ViewChild(TuiEditor, {static: true})\n    public readonly editor?: TuiEditor;\n\n    public readonly contents = new Subject<MyContentsInfo>();\n\n    // cspell:disable\n    public control = new FormControl(\n        `\n        <h1>Text editor</h1>\n        <p>\n            A text editor is a type of computer program that edits plain text. Such programs are sometimes known as \"notepad\"\n            software (e.g. Windows Notepad). Text editors are provided with operating systems and software development packages,\n            and can be used to change files such as configuration files, documentation files and programming language source\n            code.\n        </p>\n        <h2>Plain text and rich text</h2>\n        <p>\n            There are important differences between plain text (created and edited by text editors) and rich text (such as that\n            created by word processors or desktop publishing software).\n        </p>\n        <p>\n            Plain text exclusively consists of character representation. Each character is represented by a fixed-length\n            sequence of one, two, or four bytes, or as a variable-length sequence of one to four bytes, in accordance to\n            specific character encoding conventions, such as ASCII, ISO/IEC 2022, Shift JIS, UTF-8, or UTF-16. These conventions\n            define many printable characters, but also non-printing characters that control the flow of the text, such as space,\n            line break, and page break. Plain text contains no other information about the text itself, not even the character\n            encoding convention employed. Plain text is stored in text files, although text files do not exclusively store plain\n            text. Since the early days of computers, plain text was (once by necessity and now by convention) generally\n            displayed using a monospace font, such that horizontal alignment and columnar formatting were sometimes done using\n            whitespace characters.\n        </p>\n        <p>\n            Rich text, on the other hand, may contain metadata, character formatting data (e.g. typeface, size, weight and\n            style), paragraph formatting data (e.g. indentation, alignment, letter and word distribution, and space between\n            lines or other paragraphs), and page specification data (e.g. size, margin and reading direction). Rich text can be\n            very complex. Rich text can be saved in binary format (e.g. DOC), text files adhering to a markup language (e.g. RTF\n            or HTML), or in a hybrid form of both (e.g. Office Open XML).\n        </p>\n        <p>\n            Text editors are intended to open and save text files containing either plain text or anything that can be\n            interpreted as plain text, including the markup for rich text or the markup for something else (e.g. SVG).\n        </p>\n        <h2>History</h2>\n        <p>\n            Before text editors existed, computer text was punched into cards with keypunch machines. Physical boxes of these\n            thin cardboard cards were then inserted into a card reader. Magnetic tape, drum and disk card image files created\n            from such card decks often had no line-separation characters at all, and assumed fixed-length 80- or 90-character\n            records. An alternative to cards was Punched tape. It could be created by some teleprinters (such as the Teletype),\n            which used special characters to indicate ends of records. Some early operating systems included batch text editors,\n            either integrated with language processors or as separate utility programs; one early example was the ability to\n            edit SQUOZE source files for SCAT in SHARE Operating System.\n        </p>\n        <p>\n            The first interactive text editors were \"line editors\" oriented to teleprinter- or typewriter-style terminals\n            without displays. Commands (often a single keystroke) effected edits to a file at an imaginary insertion point\n            called the \"cursor\". Edits were verified by typing a command to print a small section of the file, and periodically\n            by printing the entire file. In some line editors, the cursor could be moved by commands that specified the line\n            number in the file, text strings (context) for which to search, and eventually regular expressions. Line editors\n            were major improvements over keypunching. Some line editors could be used by keypunch; editing commands could be\n            taken from a deck of cards and applied to a specified file. Some common line editors supported a \"verify\" mode in\n            which change commands displayed the altered lines.\n        </p>\n        <h5>Weird h5 headline</h5>\n        <p>\n            When computer terminals with video screens became available, screen-based text editors (sometimes called just\n            \"screen editors\") became common. One of the earliest full-screen editors was O26, which was written for the operator\n            console of the CDC 6000 series computers in 1967. Another early full-screen editor was vi. Written in the 1970s, it\n            is still a standard editor on Unix and Linux operating systems. Also written in the 1970s was the UCSD Pascal Screen\n            Oriented Editor, which was optimized both for indented source code and general text. Emacs, one of the first free\n            and open-source software projects, is another early full-screen or real-time editor, one that was ported to many\n            systems. A full-screen editor's ease-of-use and speed (compared to the line-based editors) motivated many early\n            purchases of video terminals.\n        </p>\n        <h2>Types of text editors</h2>\n        <h3>Simple text editors</h3>\n        <p>\n            Some text editors are small and simple, while others offer broad and complex functions. For example, Unix and\n            Unix-like operating systems have the pico editor (or a variant), but many also include the vi and Emacs editors.\n            Microsoft Windows systems come with the simple Notepad, though many people—especially programmers—prefer other\n            editors with more features. Under Apple Macintosh's classic Mac OS there was the native TeachText later replaced by\n            SimpleText in 1994, which was replaced in Mac OS X by TextEdit, which combines features of a text editor with those\n            typical of a word processor such as rulers, margins and multiple font selection. These features are not available\n            simultaneously, but must be switched by user command, or through the program automatically determining the file\n            type.\n        </p>\n        <h3>Word editors</h3>\n        <p>\n            Most word processors can read and write files in plain text format, allowing them to open files saved from text\n            editors. Saving these files from a word processor, however, requires ensuring the file is written in plain text\n            format, and that any text encoding or BOM settings won't obscure the file for its intended use. Non-WYSIWYG word\n            processors, such as WordStar, are more easily pressed into service as text editors, and in fact were commonly used\n            as such during the 1980s. The default file format of these word processors often resembles a markup language, with\n            the basic format being plain text and visual formatting achieved using non-printing control characters or escape\n            sequences. Later word processors like Microsoft Word store their files in a binary format and are almost never used\n            to edit plain text files.\n        </p>\n    `,\n    );\n}\n"}}]);